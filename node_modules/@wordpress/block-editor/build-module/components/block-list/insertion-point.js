import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import classnames from 'classnames';
import { last } from 'lodash';
/**
 * WordPress dependencies
 */

import { useSelect } from '@wordpress/data';
import { useState, useRef, useEffect, useCallback } from '@wordpress/element';
import { Popover } from '@wordpress/components';
import { placeCaretAtVerticalEdge } from '@wordpress/dom';
/**
 * Internal dependencies
 */

import Inserter from '../inserter';
import { getClosestTabbable } from '../writing-flow';
import { getBlockDOMNode } from '../../utils/dom';

function InsertionPointInserter(_ref) {
  var clientId = _ref.clientId,
      setIsInserterForced = _ref.setIsInserterForced,
      containerRef = _ref.containerRef;
  var ref = useRef(); // Hide the inserter above the selected block and during multi-selection.

  var isInserterHidden = useSelect(function (select) {
    var _select = select('core/block-editor'),
        getMultiSelectedBlockClientIds = _select.getMultiSelectedBlockClientIds,
        getSelectedBlockClientId = _select.getSelectedBlockClientId,
        hasMultiSelection = _select.hasMultiSelection,
        getSettings = _select.getSettings;

    var _getSettings = getSettings(),
        hasReducedUI = _getSettings.hasReducedUI;

    if (hasReducedUI) {
      return true;
    }

    var multiSelectedBlockClientIds = getMultiSelectedBlockClientIds();
    var selectedBlockClientId = getSelectedBlockClientId();
    return hasMultiSelection() ? multiSelectedBlockClientIds.includes(clientId) : clientId === selectedBlockClientId;
  }, [clientId]);

  function focusClosestTabbable(event) {
    var clientX = event.clientX,
        clientY = event.clientY,
        target = event.target; // Only handle click on the wrapper specifically, and not an event
    // bubbled from the inserter itself.

    if (target !== ref.current) {
      return;
    }

    var ownerDocument = containerRef.current.ownerDocument;
    var targetRect = target.getBoundingClientRect();
    var isReverse = clientY < targetRect.top + targetRect.height / 2;
    var blockNode = getBlockDOMNode(clientId, ownerDocument);
    var container = isReverse ? containerRef.current : blockNode;
    var closest = getClosestTabbable(blockNode, true, container) || blockNode;
    var rect = new window.DOMRect(clientX, clientY, 0, 16);
    placeCaretAtVerticalEdge(closest, isReverse, rect, false);
  }

  return (
    /* eslint-disable-next-line jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */
    createElement("div", {
      ref: ref,
      onFocus: function onFocus() {
        return setIsInserterForced(true);
      },
      onBlur: function onBlur() {
        return setIsInserterForced(false);
      },
      onClick: focusClosestTabbable // While ideally it would be enough to capture the
      // bubbling focus event from the Inserter, due to the
      // characteristics of click focusing of `button`s in
      // Firefox and Safari, it is not reliable.
      //
      // See: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
      ,
      tabIndex: -1,
      className: classnames('block-editor-block-list__insertion-point-inserter', {
        'is-inserter-hidden': isInserterHidden
      })
    }, createElement(Inserter, {
      position: "bottom center",
      clientId: clientId,
      __experimentalIsQuick: true
    }))
  );
}

function InsertionPointPopover(_ref2) {
  var clientId = _ref2.clientId,
      rootClientId = _ref2.rootClientId,
      isInserterShown = _ref2.isInserterShown,
      isInserterForced = _ref2.isInserterForced,
      setIsInserterForced = _ref2.setIsInserterForced,
      containerRef = _ref2.containerRef,
      showInsertionPoint = _ref2.showInsertionPoint;
  var element = useSelect(function (select) {
    var _select2 = select('core/block-editor'),
        getBlockOrder = _select2.getBlockOrder;

    var ownerDocument = containerRef.current.ownerDocument;
    var targetClientId = clientId || last(getBlockOrder(rootClientId));
    return getBlockDOMNode(targetClientId, ownerDocument);
  }, [clientId, rootClientId]);
  var position = clientId ? 'top' : 'bottom';
  var className = classnames('block-editor-block-list__insertion-point', {
    'is-insert-after': !clientId
  });
  return createElement(Popover, {
    noArrow: true,
    animate: false,
    anchorRef: element,
    position: "".concat(position, " right left"),
    focusOnMount: false,
    className: "block-editor-block-list__insertion-point-popover",
    __unstableSlotName: "block-toolbar",
    __unstableForcePosition: true
  }, createElement("div", {
    className: className,
    style: {
      width: element === null || element === void 0 ? void 0 : element.offsetWidth
    }
  }, (showInsertionPoint || isInserterShown || isInserterForced) && createElement("div", {
    className: "block-editor-block-list__insertion-point-indicator"
  }), (isInserterShown || isInserterForced) && createElement(InsertionPointInserter, {
    clientId: clientId,
    setIsInserterForced: setIsInserterForced,
    containerRef: containerRef
  })));
}

export default function InsertionPoint(ref) {
  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isInserterShown = _useState2[0],
      setIsInserterShown = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isInserterForced = _useState4[0],
      setIsInserterForced = _useState4[1];

  var _useState5 = useState(null),
      _useState6 = _slicedToArray(_useState5, 2),
      inserterClientId = _useState6[0],
      setInserterClientId = _useState6[1];

  var _useSelect = useSelect(function (select) {
    var _select3 = select('core/block-editor'),
        _isMultiSelecting = _select3.isMultiSelecting,
        isBlockInsertionPointVisible = _select3.isBlockInsertionPointVisible,
        getBlockInsertionPoint = _select3.getBlockInsertionPoint,
        getBlockOrder = _select3.getBlockOrder;

    var insertionPoint = getBlockInsertionPoint();
    var order = getBlockOrder(insertionPoint.rootClientId);
    return {
      isMultiSelecting: _isMultiSelecting(),
      isInserterVisible: isBlockInsertionPointVisible(),
      selectedClientId: order[insertionPoint.index],
      selectedRootClientId: insertionPoint.rootClientId
    };
  }, []),
      isMultiSelecting = _useSelect.isMultiSelecting,
      isInserterVisible = _useSelect.isInserterVisible,
      selectedClientId = _useSelect.selectedClientId,
      selectedRootClientId = _useSelect.selectedRootClientId;

  var onMouseMove = useCallback(function (event) {
    if (!event.target.classList.contains('block-editor-block-list__layout')) {
      if (isInserterShown) {
        setIsInserterShown(false);
      }

      return;
    }

    var rect = event.target.getBoundingClientRect();
    var offset = event.clientY - rect.top;
    var element = Array.from(event.target.children).find(function (blockEl) {
      return blockEl.offsetTop > offset;
    });

    if (!element) {
      return;
    } // The block may be in an alignment wrapper, so check the first direct
    // child if the element has no ID.


    if (!element.id) {
      element = element.firstElementChild;

      if (!element) {
        return;
      }
    }

    var clientId = element.id.slice('block-'.length);

    if (!clientId) {
      return;
    }

    var elementRect = element.getBoundingClientRect();

    if (event.clientX > elementRect.right || event.clientX < elementRect.left) {
      if (isInserterShown) {
        setIsInserterShown(false);
      }

      return;
    }

    setIsInserterShown(true);
    setInserterClientId(clientId);
  }, [isInserterShown, setIsInserterShown, setInserterClientId]);
  var enableMouseMove = !isInserterForced && !isMultiSelecting;
  useEffect(function () {
    if (!enableMouseMove) {
      return;
    }

    ref.current.addEventListener('mousemove', onMouseMove);
    return function () {
      ref.current.removeEventListener('mousemove', onMouseMove);
    };
  }, [enableMouseMove, onMouseMove]);
  var isVisible = isInserterShown || isInserterForced || isInserterVisible;
  return !isMultiSelecting && isVisible && createElement(InsertionPointPopover, {
    clientId: isInserterVisible ? selectedClientId : inserterClientId,
    rootClientId: selectedRootClientId,
    isInserterShown: isInserterShown,
    isInserterForced: isInserterForced,
    setIsInserterForced: setIsInserterForced,
    containerRef: ref,
    showInsertionPoint: isInserterVisible
  });
}
//# sourceMappingURL=insertion-point.js.map