import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { createElement } from "@wordpress/element";

/**
 * External dependencies
 */
import { includes } from 'lodash';
/**
 * WordPress dependencies
 */

import { Children, cloneElement, concatChildren, useEffect, useState } from '@wordpress/element';
/**
 * Internal dependencies
 */

import Popover from '../popover';
import Shortcut from '../shortcut';
import { useDebounce } from '@wordpress/compose';
/**
 * Time over children to wait before showing tooltip
 *
 * @type {number}
 */

export var TOOLTIP_DELAY = 700;

var emitToChild = function emitToChild(children, eventName, event) {
  if (Children.count(children) !== 1) {
    return;
  }

  var child = Children.only(children);

  if (typeof child.props[eventName] === 'function') {
    child.props[eventName](event);
  }
};

function Tooltip(_ref) {
  var children = _ref.children,
      position = _ref.position,
      text = _ref.text,
      shortcut = _ref.shortcut;

  /**
   * Whether a mouse is currently pressed, used in determining whether
   * to handle a focus event as displaying the tooltip immediately.
   *
   * @type {boolean}
   */
  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isMouseDown = _useState2[0],
      setIsMouseDown = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isOver = _useState4[0],
      setIsOver = _useState4[1];

  var delayedSetIsOver = useDebounce(setIsOver, TOOLTIP_DELAY);

  var createMouseDown = function createMouseDown(event) {
    // Preserve original child callback behavior
    emitToChild(children, 'onMouseDown', event); // On mouse down, the next `mouseup` should revert the value of the
    // instance property and remove its own event handler. The bind is
    // made on the document since the `mouseup` might not occur within
    // the bounds of the element.

    document.addEventListener('mouseup', cancelIsMouseDown);
    setIsMouseDown(true);
  };

  var createMouseUp = function createMouseUp(event) {
    emitToChild(children, 'onMouseUp', event);
    document.removeEventListener('mouseup', cancelIsMouseDown);
    setIsMouseDown(false);
  };

  var createMouseEvent = function createMouseEvent(type) {
    if (type === 'mouseUp') return createMouseUp;
    if (type === 'mouseDown') return createMouseDown;
  };
  /**
   * Prebound `isInMouseDown` handler, created as a constant reference to
   * assure ability to remove in component unmount.
   *
   * @type {Function}
   */


  var cancelIsMouseDown = createMouseEvent('mouseUp');

  var createToggleIsOver = function createToggleIsOver(eventName, isDelayed) {
    return function (event) {
      // Preserve original child callback behavior
      emitToChild(children, eventName, event); // Mouse events behave unreliably in React for disabled elements,
      // firing on mouseenter but not mouseleave.  Further, the default
      // behavior for disabled elements in some browsers is to ignore
      // mouse events. Don't bother trying to to handle them.
      //
      // See: https://github.com/facebook/react/issues/4251

      if (event.currentTarget.disabled) {
        return;
      } // A focus event will occur as a result of a mouse click, but it
      // should be disambiguated between interacting with the button and
      // using an explicit focus shift as a cue to display the tooltip.


      if ('focus' === event.type && isMouseDown) {
        return;
      } // Needed in case unsetting is over while delayed set pending, i.e.
      // quickly blur/mouseleave before delayedSetIsOver is called


      delayedSetIsOver.cancel();

      var _isOver = includes(['focus', 'mouseenter'], event.type);

      if (_isOver === isOver) {
        return;
      }

      if (isDelayed) {
        delayedSetIsOver(_isOver);
      } else {
        setIsOver(_isOver);
      }
    };
  };

  var clearOnUnmount = function clearOnUnmount() {
    delayedSetIsOver.cancel();
  };

  useEffect(function () {
    return clearOnUnmount;
  }, []);

  if (Children.count(children) !== 1) {
    if ('development' === process.env.NODE_ENV) {
      // eslint-disable-next-line no-console
      console.error('Tooltip should be called with only a single child element.');
    }

    return children;
  }

  var child = Children.only(children);
  return cloneElement(child, {
    onMouseEnter: createToggleIsOver('onMouseEnter', true),
    onMouseLeave: createToggleIsOver('onMouseLeave'),
    onClick: createToggleIsOver('onClick'),
    onFocus: createToggleIsOver('onFocus'),
    onBlur: createToggleIsOver('onBlur'),
    onMouseDown: createMouseEvent('mouseDown'),
    children: concatChildren(child.props.children, isOver && createElement(Popover, {
      focusOnMount: false,
      position: position,
      className: "components-tooltip",
      "aria-hidden": "true",
      animate: false,
      noArrow: true
    }, text, createElement(Shortcut, {
      className: "components-tooltip__shortcut",
      shortcut: shortcut
    })))
  });
}

export default Tooltip;
//# sourceMappingURL=index.js.map