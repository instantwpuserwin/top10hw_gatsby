"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regeneratorRuntime2 = require("@babel/runtime/regenerator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.receiveUserQuery = receiveUserQuery;
exports.receiveCurrentUser = receiveCurrentUser;
exports.addEntities = addEntities;
exports.receiveEntityRecords = receiveEntityRecords;
exports.receiveCurrentTheme = receiveCurrentTheme;
exports.receiveThemeSupports = receiveThemeSupports;
exports.receiveEmbedPreview = receiveEmbedPreview;
exports.deleteEntityRecord = deleteEntityRecord;
exports.editEntityRecord = editEntityRecord;
exports.undo = undo;
exports.redo = redo;
exports.__unstableCreateUndoLevel = __unstableCreateUndoLevel;
exports.saveEntityRecord = saveEntityRecord;
exports.saveEditedEntityRecord = saveEditedEntityRecord;
exports.receiveUploadPermissions = receiveUploadPermissions;
exports.receiveUserPermission = receiveUserPermission;
exports.receiveAutosaves = receiveAutosaves;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lodash = require("lodash");

var _uuid = require("uuid");

var _data = require("@wordpress/data");

var _dataControls = require("@wordpress/data-controls");

var _url = require("@wordpress/url");

var _queriedData = require("./queried-data");

var _entities = require("./entities");

var _locks = require("./locks");

var _marked = /*#__PURE__*/_regeneratorRuntime2.mark(deleteEntityRecord),
    _marked2 = /*#__PURE__*/_regeneratorRuntime2.mark(editEntityRecord),
    _marked3 = /*#__PURE__*/_regeneratorRuntime2.mark(undo),
    _marked4 = /*#__PURE__*/_regeneratorRuntime2.mark(redo),
    _marked5 = /*#__PURE__*/_regeneratorRuntime2.mark(saveEntityRecord),
    _marked6 = /*#__PURE__*/_regeneratorRuntime2.mark(saveEditedEntityRecord);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Returns an action object used in signalling that authors have been received.
 *
 * @param {string}       queryID Query ID.
 * @param {Array|Object} users   Users received.
 *
 * @return {Object} Action object.
 */
function receiveUserQuery(queryID, users) {
  return {
    type: 'RECEIVE_USER_QUERY',
    users: (0, _lodash.castArray)(users),
    queryID: queryID
  };
}
/**
 * Returns an action used in signalling that the current user has been received.
 *
 * @param {Object} currentUser Current user object.
 *
 * @return {Object} Action object.
 */


function receiveCurrentUser(currentUser) {
  return {
    type: 'RECEIVE_CURRENT_USER',
    currentUser: currentUser
  };
}
/**
 * Returns an action object used in adding new entities.
 *
 * @param {Array} entities  Entities received.
 *
 * @return {Object} Action object.
 */


function addEntities(entities) {
  return {
    type: 'ADD_ENTITIES',
    entities: entities
  };
}
/**
 * Returns an action object used in signalling that entity records have been received.
 *
 * @param {string}       kind            Kind of the received entity.
 * @param {string}       name            Name of the received entity.
 * @param {Array|Object} records         Records received.
 * @param {?Object}      query           Query Object.
 * @param {?boolean}     invalidateCache Should invalidate query caches.
 * @param {?Object}      edits           Edits to reset.
 * @return {Object} Action object.
 */


function receiveEntityRecords(kind, name, records, query) {
  var invalidateCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var edits = arguments.length > 5 ? arguments[5] : undefined;

  // Auto drafts should not have titles, but some plugins rely on them so we can't filter this
  // on the server.
  if (kind === 'postType') {
    records = (0, _lodash.castArray)(records).map(function (record) {
      return record.status === 'auto-draft' ? _objectSpread(_objectSpread({}, record), {}, {
        title: ''
      }) : record;
    });
  }

  var action;

  if (query) {
    action = (0, _queriedData.receiveQueriedItems)(records, query, edits);
  } else {
    action = (0, _queriedData.receiveItems)(records, edits);
  }

  return _objectSpread(_objectSpread({}, action), {}, {
    kind: kind,
    name: name,
    invalidateCache: invalidateCache
  });
}
/**
 * Returns an action object used in signalling that the current theme has been received.
 *
 * @param {Object} currentTheme The current theme.
 *
 * @return {Object} Action object.
 */


function receiveCurrentTheme(currentTheme) {
  return {
    type: 'RECEIVE_CURRENT_THEME',
    currentTheme: currentTheme
  };
}
/**
 * Returns an action object used in signalling that the index has been received.
 *
 * @param {Object} themeSupports Theme support for the current theme.
 *
 * @return {Object} Action object.
 */


function receiveThemeSupports(themeSupports) {
  return {
    type: 'RECEIVE_THEME_SUPPORTS',
    themeSupports: themeSupports
  };
}
/**
 * Returns an action object used in signalling that the preview data for
 * a given URl has been received.
 *
 * @param {string}  url     URL to preview the embed for.
 * @param {*}       preview Preview data.
 *
 * @return {Object} Action object.
 */


function receiveEmbedPreview(url, preview) {
  return {
    type: 'RECEIVE_EMBED_PREVIEW',
    url: url,
    preview: preview
  };
}
/**
 * Action triggered to delete an entity record.
 *
 * @param {string}  kind              Kind of the deleted entity.
 * @param {string}  name              Name of the deleted entity.
 * @param {string}  recordId          Record ID of the deleted entity.
 * @param {?Object} query             Special query parameters for the DELETE API call.
 */


function deleteEntityRecord(kind, name, recordId, query) {
  var entities, entity, error, deletedRecord, lock, path;
  return _regenerator.default.wrap(function deleteEntityRecord$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, _entities.getKindEntities)(kind);

        case 2:
          entities = _context.sent;
          entity = (0, _lodash.find)(entities, {
            kind: kind,
            name: name
          });
          deletedRecord = false;

          if (entity) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("return");

        case 7:
          return _context.delegateYield((0, _locks.__unstableAcquireStoreLock)('core', ['entities', 'data', kind, name, recordId], {
            exclusive: true
          }), "t0", 8);

        case 8:
          lock = _context.t0;
          _context.prev = 9;
          _context.next = 12;
          return {
            type: 'DELETE_ENTITY_RECORD_START',
            kind: kind,
            name: name,
            recordId: recordId
          };

        case 12:
          _context.prev = 12;
          path = "".concat(entity.baseURL, "/").concat(recordId);

          if (query) {
            path = (0, _url.addQueryArgs)(path, query);
          }

          _context.next = 17;
          return (0, _dataControls.apiFetch)({
            path: path,
            method: 'DELETE'
          });

        case 17:
          deletedRecord = _context.sent;
          _context.next = 20;
          return (0, _queriedData.removeItems)(kind, name, recordId, true);

        case 20:
          _context.next = 25;
          break;

        case 22:
          _context.prev = 22;
          _context.t1 = _context["catch"](12);
          error = _context.t1;

        case 25:
          _context.next = 27;
          return {
            type: 'DELETE_ENTITY_RECORD_FINISH',
            kind: kind,
            name: name,
            recordId: recordId,
            error: error
          };

        case 27:
          return _context.abrupt("return", deletedRecord);

        case 28:
          _context.prev = 28;
          return _context.delegateYield((0, _locks.__unstableReleaseStoreLock)(lock), "t2", 30);

        case 30:
          return _context.finish(28);

        case 31:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[9,, 28, 31], [12, 22]]);
}
/**
 * Returns an action object that triggers an
 * edit to an entity record.
 *
 * @param {string} kind     Kind of the edited entity record.
 * @param {string} name     Name of the edited entity record.
 * @param {number} recordId Record ID of the edited entity record.
 * @param {Object} edits    The edits.
 * @param {Object} options  Options for the edit.
 * @param {boolean} options.undoIgnore Whether to ignore the edit in undo history or not.
 *
 * @return {Object} Action object.
 */


function editEntityRecord(kind, name, recordId, edits) {
  var options,
      entity,
      _entity$transientEdit,
      transientEdits,
      _entity$mergedEdits,
      mergedEdits,
      record,
      editedRecord,
      edit,
      _args2 = arguments;

  return _regenerator.default.wrap(function editEntityRecord$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          options = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : {};
          _context2.next = 3;
          return _data.controls.select('core', 'getEntity', kind, name);

        case 3:
          entity = _context2.sent;

          if (entity) {
            _context2.next = 6;
            break;
          }

          throw new Error("The entity being edited (".concat(kind, ", ").concat(name, ") does not have a loaded config."));

        case 6:
          _entity$transientEdit = entity.transientEdits, transientEdits = _entity$transientEdit === void 0 ? {} : _entity$transientEdit, _entity$mergedEdits = entity.mergedEdits, mergedEdits = _entity$mergedEdits === void 0 ? {} : _entity$mergedEdits;
          _context2.next = 9;
          return _data.controls.select('core', 'getRawEntityRecord', kind, name, recordId);

        case 9:
          record = _context2.sent;
          _context2.next = 12;
          return _data.controls.select('core', 'getEditedEntityRecord', kind, name, recordId);

        case 12:
          editedRecord = _context2.sent;
          edit = {
            kind: kind,
            name: name,
            recordId: recordId,
            // Clear edits when they are equal to their persisted counterparts
            // so that the property is not considered dirty.
            edits: Object.keys(edits).reduce(function (acc, key) {
              var recordValue = record[key];
              var editedRecordValue = editedRecord[key];
              var value = mergedEdits[key] ? _objectSpread(_objectSpread({}, editedRecordValue), edits[key]) : edits[key];
              acc[key] = (0, _lodash.isEqual)(recordValue, value) ? undefined : value;
              return acc;
            }, {}),
            transientEdits: transientEdits
          };
          return _context2.abrupt("return", _objectSpread(_objectSpread({
            type: 'EDIT_ENTITY_RECORD'
          }, edit), {}, {
            meta: {
              undo: !options.undoIgnore && _objectSpread(_objectSpread({}, edit), {}, {
                // Send the current values for things like the first undo stack entry.
                edits: Object.keys(edits).reduce(function (acc, key) {
                  acc[key] = editedRecord[key];
                  return acc;
                }, {})
              })
            }
          }));

        case 15:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}
/**
 * Action triggered to undo the last edit to
 * an entity record, if any.
 */


function undo() {
  var undoEdit;
  return _regenerator.default.wrap(function undo$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return _data.controls.select('core', 'getUndoEdit');

        case 2:
          undoEdit = _context3.sent;

          if (undoEdit) {
            _context3.next = 5;
            break;
          }

          return _context3.abrupt("return");

        case 5:
          _context3.next = 7;
          return _objectSpread(_objectSpread({
            type: 'EDIT_ENTITY_RECORD'
          }, undoEdit), {}, {
            meta: {
              isUndo: true
            }
          });

        case 7:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
}
/**
 * Action triggered to redo the last undoed
 * edit to an entity record, if any.
 */


function redo() {
  var redoEdit;
  return _regenerator.default.wrap(function redo$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return _data.controls.select('core', 'getRedoEdit');

        case 2:
          redoEdit = _context4.sent;

          if (redoEdit) {
            _context4.next = 5;
            break;
          }

          return _context4.abrupt("return");

        case 5:
          _context4.next = 7;
          return _objectSpread(_objectSpread({
            type: 'EDIT_ENTITY_RECORD'
          }, redoEdit), {}, {
            meta: {
              isRedo: true
            }
          });

        case 7:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4);
}
/**
 * Forces the creation of a new undo level.
 *
 * @return {Object} Action object.
 */


function __unstableCreateUndoLevel() {
  return {
    type: 'CREATE_UNDO_LEVEL'
  };
}
/**
 * Action triggered to save an entity record.
 *
 * @param {string}  kind                       Kind of the received entity.
 * @param {string}  name                       Name of the received entity.
 * @param {Object}  record                     Record to be saved.
 * @param {Object}  options                    Saving options.
 * @param {boolean} [options.isAutosave=false] Whether this is an autosave.
 */


function saveEntityRecord(kind, name, record) {
  var _ref,
      _ref$isAutosave,
      isAutosave,
      entities,
      entity,
      entityIdKey,
      recordId,
      lock,
      _i,
      _Object$entries,
      _Object$entries$_i,
      key,
      value,
      evaluatedValue,
      updatedRecord,
      error,
      path,
      persistedRecord,
      currentUser,
      currentUserId,
      autosavePost,
      data,
      newRecord,
      edits,
      _args5 = arguments;

  return _regenerator.default.wrap(function saveEntityRecord$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _ref = _args5.length > 3 && _args5[3] !== undefined ? _args5[3] : {
            isAutosave: false
          }, _ref$isAutosave = _ref.isAutosave, isAutosave = _ref$isAutosave === void 0 ? false : _ref$isAutosave;
          _context5.next = 3;
          return (0, _entities.getKindEntities)(kind);

        case 3:
          entities = _context5.sent;
          entity = (0, _lodash.find)(entities, {
            kind: kind,
            name: name
          });

          if (entity) {
            _context5.next = 7;
            break;
          }

          return _context5.abrupt("return");

        case 7:
          entityIdKey = entity.key || _entities.DEFAULT_ENTITY_KEY;
          recordId = record[entityIdKey];
          return _context5.delegateYield((0, _locks.__unstableAcquireStoreLock)('core', ['entities', 'data', kind, name, recordId || (0, _uuid.v4)()], {
            exclusive: true
          }), "t0", 10);

        case 10:
          lock = _context5.t0;
          _context5.prev = 11;
          _i = 0, _Object$entries = Object.entries(record);

        case 13:
          if (!(_i < _Object$entries.length)) {
            _context5.next = 27;
            break;
          }

          _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];

          if (!(typeof value === 'function')) {
            _context5.next = 24;
            break;
          }

          _context5.t1 = value;
          _context5.next = 19;
          return _data.controls.select('core', 'getEditedEntityRecord', kind, name, recordId);

        case 19:
          _context5.t2 = _context5.sent;
          evaluatedValue = (0, _context5.t1)(_context5.t2);
          _context5.next = 23;
          return editEntityRecord(kind, name, recordId, (0, _defineProperty2.default)({}, key, evaluatedValue), {
            undoIgnore: true
          });

        case 23:
          record[key] = evaluatedValue;

        case 24:
          _i++;
          _context5.next = 13;
          break;

        case 27:
          _context5.next = 29;
          return {
            type: 'SAVE_ENTITY_RECORD_START',
            kind: kind,
            name: name,
            recordId: recordId,
            isAutosave: isAutosave
          };

        case 29:
          _context5.prev = 29;
          path = "".concat(entity.baseURL).concat(recordId ? '/' + recordId : '');
          _context5.next = 33;
          return _data.controls.select('core', 'getRawEntityRecord', kind, name, recordId);

        case 33:
          persistedRecord = _context5.sent;

          if (!isAutosave) {
            _context5.next = 58;
            break;
          }

          _context5.next = 37;
          return _data.controls.select('core', 'getCurrentUser');

        case 37:
          currentUser = _context5.sent;
          currentUserId = currentUser ? currentUser.id : undefined;
          _context5.next = 41;
          return _data.controls.select('core', 'getAutosave', persistedRecord.type, persistedRecord.id, currentUserId);

        case 41:
          autosavePost = _context5.sent;
          // Autosaves need all expected fields to be present.
          // So we fallback to the previous autosave and then
          // to the actual persisted entity if the edits don't
          // have a value.
          data = _objectSpread(_objectSpread(_objectSpread({}, persistedRecord), autosavePost), record);
          data = Object.keys(data).reduce(function (acc, key) {
            if (['title', 'excerpt', 'content'].includes(key)) {
              // Edits should be the "raw" attribute values.
              acc[key] = (0, _lodash.get)(data[key], 'raw', data[key]);
            }

            return acc;
          }, {
            status: data.status === 'auto-draft' ? 'draft' : data.status
          });
          _context5.next = 46;
          return (0, _dataControls.apiFetch)({
            path: "".concat(path, "/autosaves"),
            method: 'POST',
            data: data
          });

        case 46:
          updatedRecord = _context5.sent;

          if (!(persistedRecord.id === updatedRecord.id)) {
            _context5.next = 54;
            break;
          }

          newRecord = _objectSpread(_objectSpread(_objectSpread({}, persistedRecord), data), updatedRecord);
          newRecord = Object.keys(newRecord).reduce(function (acc, key) {
            // These properties are persisted in autosaves.
            if (['title', 'excerpt', 'content'].includes(key)) {
              // Edits should be the "raw" attribute values.
              acc[key] = (0, _lodash.get)(newRecord[key], 'raw', newRecord[key]);
            } else if (key === 'status') {
              // Status is only persisted in autosaves when going from
              // "auto-draft" to "draft".
              acc[key] = persistedRecord.status === 'auto-draft' && newRecord.status === 'draft' ? newRecord.status : persistedRecord.status;
            } else {
              // These properties are not persisted in autosaves.
              acc[key] = (0, _lodash.get)(persistedRecord[key], 'raw', persistedRecord[key]);
            }

            return acc;
          }, {});
          _context5.next = 52;
          return receiveEntityRecords(kind, name, newRecord, undefined, true);

        case 52:
          _context5.next = 56;
          break;

        case 54:
          _context5.next = 56;
          return receiveAutosaves(persistedRecord.id, updatedRecord);

        case 56:
          _context5.next = 65;
          break;

        case 58:
          edits = record;

          if (entity.__unstablePrePersist) {
            edits = _objectSpread(_objectSpread({}, edits), entity.__unstablePrePersist(persistedRecord, edits));
          }

          _context5.next = 62;
          return (0, _dataControls.apiFetch)({
            path: path,
            method: recordId ? 'PUT' : 'POST',
            data: edits
          });

        case 62:
          updatedRecord = _context5.sent;
          _context5.next = 65;
          return receiveEntityRecords(kind, name, updatedRecord, undefined, true, edits);

        case 65:
          _context5.next = 70;
          break;

        case 67:
          _context5.prev = 67;
          _context5.t3 = _context5["catch"](29);
          error = _context5.t3;

        case 70:
          _context5.next = 72;
          return {
            type: 'SAVE_ENTITY_RECORD_FINISH',
            kind: kind,
            name: name,
            recordId: recordId,
            error: error,
            isAutosave: isAutosave
          };

        case 72:
          return _context5.abrupt("return", updatedRecord);

        case 73:
          _context5.prev = 73;
          return _context5.delegateYield((0, _locks.__unstableReleaseStoreLock)(lock), "t4", 75);

        case 75:
          return _context5.finish(73);

        case 76:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, null, [[11,, 73, 76], [29, 67]]);
}
/**
 * Action triggered to save an entity record's edits.
 *
 * @param {string} kind     Kind of the entity.
 * @param {string} name     Name of the entity.
 * @param {Object} recordId ID of the record.
 * @param {Object} options  Saving options.
 */


function saveEditedEntityRecord(kind, name, recordId, options) {
  var edits, record;
  return _regenerator.default.wrap(function saveEditedEntityRecord$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return _data.controls.select('core', 'hasEditsForEntityRecord', kind, name, recordId);

        case 2:
          if (_context6.sent) {
            _context6.next = 4;
            break;
          }

          return _context6.abrupt("return");

        case 4:
          _context6.next = 6;
          return _data.controls.select('core', 'getEntityRecordNonTransientEdits', kind, name, recordId);

        case 6:
          edits = _context6.sent;
          record = _objectSpread({
            id: recordId
          }, edits);
          return _context6.delegateYield(saveEntityRecord(kind, name, record, options), "t0", 9);

        case 9:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked6);
}
/**
 * Returns an action object used in signalling that Upload permissions have been received.
 *
 * @param {boolean} hasUploadPermissions Does the user have permission to upload files?
 *
 * @return {Object} Action object.
 */


function receiveUploadPermissions(hasUploadPermissions) {
  return {
    type: 'RECEIVE_USER_PERMISSION',
    key: 'create/media',
    isAllowed: hasUploadPermissions
  };
}
/**
 * Returns an action object used in signalling that the current user has
 * permission to perform an action on a REST resource.
 *
 * @param {string}  key       A key that represents the action and REST resource.
 * @param {boolean} isAllowed Whether or not the user can perform the action.
 *
 * @return {Object} Action object.
 */


function receiveUserPermission(key, isAllowed) {
  return {
    type: 'RECEIVE_USER_PERMISSION',
    key: key,
    isAllowed: isAllowed
  };
}
/**
 * Returns an action object used in signalling that the autosaves for a
 * post have been received.
 *
 * @param {number}       postId    The id of the post that is parent to the autosave.
 * @param {Array|Object} autosaves An array of autosaves or singular autosave object.
 *
 * @return {Object} Action object.
 */


function receiveAutosaves(postId, autosaves) {
  return {
    type: 'RECEIVE_AUTOSAVES',
    postId: postId,
    autosaves: (0, _lodash.castArray)(autosaves)
  };
}
//# sourceMappingURL=actions.js.map